
## Software Requirements Specification (SRS)

### Comprehensive Internship Management System (IMS)

#### 1. Introduction

##### 1.1 Purpose
This Software Requirements Specification (SRS) document provides a comprehensive description of the Comprehensive Internship Management System (IMS). It details the system's functionalities, features, and constraints to ensure a clear understanding of the system's requirements and expected performance.

##### 1.2 Scope
The IMS aims to streamline the internship management process for students, companies, university staff, and the Industrial Liaison Office (ILO). The system offers a centralized platform for managing internship applications, monitoring progress, and facilitating support through advanced technologies. Key features include:

- Student registration and profile management
- Internship search, application, and placement
- Company registration and internship posting
- Application tracking and management
- Progress reporting and evaluation
- Supervision management (school-based and company-based)
- Department evaluation
- Industrial Liaison Office oversight
- Staff support and system administration
- GPS and route navigation for staff

##### 1.3 Definitions, Acronyms, and Abbreviations
- **IMS:** Internship Management System
- **NLP:** Natural Language Processing
- **Attachy:** NLP-powered assistant integrated into the IMS
- **GPS:** Global Positioning System
- **ILO:** Industrial Liaison Office

##### 1.4 References
- Project Proposal Overview Document
- Final Year Project - Chapter One Document
- Industrial Attachment Forms and Guidelines

##### 1.5 Overview
This SRS document is organized into the following sections:
1. Introduction
2. Overall Description
3. System Features
4. External Interface Requirements
5. System Requirements
6. Other Non-Functional Requirements

#### 2. Overall Description

##### 2.1 Product Perspective
The IMS will be a web-based application accessible through standard web browsers. It will integrate with existing university systems and databases to retrieve and store information. The system will use a modular architecture to ensure scalability and flexibility.

##### 2.2 Product Functions
The IMS will provide the following core functions:
- Student management and internship application
- Company management and internship posting
- Application tracking and monitoring
- Progress reporting and evaluation
- Supervision management (school-based and company-based)
- Department evaluation
- Industrial Liaison Office oversight
- Staff support and system administration
- GPS and route navigation for staff

##### 2.3 User Classes and Characteristics
- **Students:** Undergraduate and postgraduate students seeking internships.
- **Companies:** Organizations offering internship opportunities.
- **Company-based Supervisors:** Employees of the company overseeing student internships.
- **School-based Supervisors:** University staff assigned to supervise students during internships.
- **Departments:** Academic departments responsible for evaluating student reports.
- **Industrial Liaison Office:** University department overseeing all internship activities.

##### 2.4 Operating Environment
The IMS will operate in a web-based environment, accessible through modern web browsers on various devices, including desktops, laptops, tablets, and smartphones.

##### 2.5 Design and Implementation Constraints
- Integration with existing university systems and databases
- Compliance with data protection and privacy regulations
- High availability and performance requirements
- Mobile-friendly interface for supervisors using GPS navigation

##### 2.6 User Documentation
User manuals, online help, and video tutorials will be provided to guide users in using the system. Specific documentation will be created for each user class.

##### 2.7 Assumptions and Dependencies
- Users will have access to the internet and modern web browsers.
- The university will provide necessary APIs for system integration.
- Companies will cooperate in providing accurate information and timely evaluations.

#### 3. System Features

##### 3.1 Student Management
**Description:** Allows students to register, create, and manage their profiles, apply for internships, and manage their internship activities.

**Functional Requirements:**
- Students can log in using credentials provided by the school.
- Students can update personal and academic information.
- Students can upload and manage resumes and other documents.
- Students can view a list of available companies seeking interns.
- Students can search for internships using filters (e.g., location, industry, duration).
- Students can apply for internships directly through the platform.
- Students can track the status of their applications.
- Students can fill out an "Assumption of Duty" form on the first day of internship.
- Students can fill in daily activity logs.
- Students can edit their daily logs until reviewed by their assigned supervisor.
- Students can submit monthly work experience summaries.
- Students can view their logbook results after supervision.
- Students can submit final attachment reports through the platform.

##### 3.2 Company Management
**Description:** Allows companies to register, create profiles, post internship opportunities, and manage interns.

**Functional Requirements:**
- Companies can register and create profiles.
- Companies can post and manage internship opportunities.
- Companies can view and manage student applications.
- Companies can schedule and manage interviews with applicants.
- Companies can designate a company-based supervisor for each intern.
- Company-based supervisors can view and comment on students' weekly activities.
- Company-based supervisors can endorse students' logbooks weekly.
- Company-based supervisors can write final comments and grade students at the end of the internship.

##### 3.3 Supervision Management
**Description:** Manages the assignment and activities of school-based and company-based supervisors.

**Functional Requirements:**
- The system assigns school-based supervisors to students based on department and geographic location.
- School-based supervisors can view assigned students' locations and use GPS for navigation.
- School-based supervisors can view students' daily logs and activities.
- School-based supervisors can mark logbooks, endorse them, and provide comments.
- School-based supervisors can grade students' performance using a standardized form.
- The system balances supervisor workload based on student distribution and location.
- Supervisors can generate and submit evaluation reports.

##### 3.4 Department Management
**Description:** Allows academic departments to evaluate student reports and provide final grades.

**Functional Requirements:**
- Departments can access and grade students' final attachment reports.
- Departments can view supervisor evaluations and logbook grades.
- The system calculates final grades based on logbook marks and report grades according to scales set by the Industrial Liaison Office.
- Departments can generate performance reports for their students.

##### 3.5 Industrial Liaison Office Management
**Description:** Provides overall system management and oversight capabilities for the Industrial Liaison Office.

**Functional Requirements:**
- The ILO can manage and oversee all system operations.
- Administrators can alter any data in the system.
- The office can finalize all operations and halt processes when necessary.
- The system supports different roles within the office (directors, admins, officers, etc.).
- The ILO can set and adjust grading scales and evaluation criteria.
- The ILO can generate comprehensive reports on internship programs.

##### 3.6 Application Tracking and Monitoring
**Description:** Enables all stakeholders to track and monitor the status of internship applications and placements.

**Functional Requirements:**
- Students can view the status of their applications.
- Companies can update the status of student applications.
- The ILO can monitor the application process and provide support as needed.
- The system generates notifications for status changes and upcoming deadlines.

##### 3.7 Progress Reporting and Evaluation
**Description:** Facilitates the reporting and evaluation of student progress throughout the internship.

**Functional Requirements:**
- Students can submit daily logs and monthly summaries.
- Company-based supervisors can provide weekly endorsements and feedback.
- School-based supervisors can evaluate student performance during site visits.
- The system calculates and combines scores from various evaluation components.
- Stakeholders can view progress reports and evaluations according to their roles.

##### 3.8 Staff Support and System Administration
**Description:** Provides tools for university staff to manage the system, support users, and oversee the internship process.

**Functional Requirements:**
- Staff can manage student, company, and supervisor profiles.
- Staff can oversee internship postings and applications.
- Staff can generate reports and analytics.
- Staff can configure system settings and user access.
- The system provides a help desk function for user support.

##### 3.9 GPS and Route Navigation
**Description:** Provides navigation tools for school-based supervisors to locate and travel to internship sites.

**Functional Requirements:**
- School-based supervisors can view the location of internship sites on a map.
- The system provides optimal routes for supervisors to visit multiple sites.
- Supervisors can use GPS navigation to travel to sites.
- The system tracks and logs supervisor visits for reporting purposes.

#### 4. External Interface Requirements

##### 4.1 User Interfaces
- **Web Interface:** The IMS will provide a responsive web interface accessible through modern web browsers.
- **Mobile Interface:** A mobile-friendly interface will be provided for supervisors using GPS navigation.

##### 4.2 Hardware Interfaces
- **Server Requirements:** The IMS will be hosted on servers meeting performance and scalability requirements.
- **GPS Integration:** The system will interface with mobile device GPS for navigation features.

##### 4.3 Software Interfaces
- **University Systems:** Integration with existing university systems and databases will be facilitated through APIs.
- **Mapping Services:** Integration with mapping services for GPS and route navigation features.

##### 4.4 Communications Interfaces
- **Internet Connectivity:** Users will access the IMS through an internet connection.
- **Email Integration:** The system will send notifications and alerts via email.

#### 5. System Requirements

##### 5.1 Functional Requirements
- The system must implement all features described in Section 3: System Features.
- The system must support the complete workflow for student application, placement, supervision, and evaluation.
- The system must implement all forms as described, including the Organization Profile, Industrial Attachment Orientation Form, and Supervisor Assessment Form.
- The system must calculate and combine scores from logbooks, supervisor assessments, and final reports according to the

 Industrial Liaison Office's scaling system.
- The system must provide role-based access control for all user types.
- The system must generate appropriate notifications and alerts for all stakeholders.

##### 5.2 Non-Functional Requirements
- **Performance:** The system must handle high volumes of users and transactions efficiently.
- **Scalability:** The system must be scalable to accommodate increasing numbers of users and data.
- **Security:** The system must ensure data protection and privacy, implementing robust authentication and authorization mechanisms.
- **Usability:** The system must provide an intuitive and user-friendly interface for all user types.
- **Reliability:** The system must ensure high availability and minimal downtime.
- **Maintainability:** The system must be designed for ease of maintenance and updates.

#### 6. Other Non-Functional Requirements

##### 6.1 Security Requirements
- The system must implement robust authentication and authorization mechanisms.
- The system must encrypt sensitive data in transit and at rest.
- The system must maintain an audit trail of all significant actions.

##### 6.2 Reliability Requirements
- The system must ensure high availability with an uptime of at least 99.9%.
- The system must include backup and disaster recovery mechanisms.

##### 6.3 Maintainability Requirements
- The system must be designed with a modular architecture to facilitate updates and expansions.
- The system must provide comprehensive logging and error reporting.

##### 6.4 Portability Requirements
- The system must be accessible on various devices, including desktops, laptops, tablets, and smartphones.
- The system must support major web browsers (Chrome, Firefox, Safari, Edge).

#models.py
from bson import ObjectId
from pydantic import BaseModel, Field, EmailStr, HttpUrl, ConfigDict
from typing import Any, Dict, Optional, List, Annotated
from datetime import datetime

class PyObjectId(ObjectId):
    @classmethod
    def __get_validators__(cls):
        yield cls.validate

    @classmethod
    def validate(cls, v):
        if not ObjectId.is_valid(v):
            raise ValueError("Invalid ObjectId")
        return ObjectId(v)

    @classmethod
    def __get_pydantic_json_schema__(cls, _schema: Any, _handler: Any) -> Dict[str, Any]:
        return {"type": "string"}

class BaseModelWithConfig(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
        arbitrary_types_allowed=True,
        json_encoders={ObjectId: str}
    )

class Address(BaseModelWithConfig):
    street: str
    city: str
    state: str
    country: str
    postal_code: str
    latitude: Optional[float] = None
    longitude: Optional[float] = None

class ContactInfo(BaseModelWithConfig):
    phone: str
    alternative_phone: Optional[str] = None
    email: EmailStr
    alternative_email: Optional[EmailStr] = None

class Department(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    name: str
    faculty_id: PyObjectId
    description: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Faculty(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    name: str
    description: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Programme(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    name: str
    department_id: PyObjectId
    description: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class User(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    role: str  # E.g., 'Student', 'Company', 'Supervisor', 'Admin','ILO'
    email: EmailStr
    password: str
    first_name: str
    last_name: str
    profile_picture: Optional[HttpUrl] = None
    contact_info: ContactInfo
    address: Address
    date_of_birth: datetime
    gender: str
    nationality: str
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class AcademicInfo(BaseModelWithConfig):
    institution: str
    degree: str
    major: str
    year_of_study: int
    gpa: float

class Student(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    user_id: PyObjectId
    registration_number: str
    academic_info: AcademicInfo
    resume_url: Optional[HttpUrl] = None
    skills: List[str] = []
    interests: List[str] = []
    internships: List[PyObjectId] = []  # List of internship IDs
    projects: List[Dict[str, Any]] = []
    department_id: PyObjectId
    programme_id: PyObjectId
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Company(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    user_id: PyObjectId
    company_name: str
    industry: str
    company_size: str
    year_founded: int
    website: HttpUrl
    logo_url: Optional[HttpUrl] = None
    description: str
    address: Address
    contact_info: ContactInfo
    internships_posted: List[PyObjectId] = []  # List of internship IDs
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Internship(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    company_id: PyObjectId
    title: str
    description: str
    responsibilities: List[str]
    requirements: List[str]
    location: Address
    industry: str
    internship_type: str
    duration: str
    start_date: datetime
    end_date: datetime
    stipend: Optional[float] = None
    application_deadline: datetime
    max_applications: int
    status: str
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Application(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    student_id: PyObjectId
    internship_id: PyObjectId
    status: str  # E.g., 'Applied', 'Accepted', 'Rejected', 'Withdrawn'
    application_date: datetime
    cover_letter: str
    resume_url: HttpUrl
    acceptance_date: Optional[datetime] = None
    rejection_date: Optional[datetime] = None
    withdrawal_date: Optional[datetime] = None
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Supervisor(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    user_id: PyObjectId
    type: str  # E.g., 'Company' or 'School'
    department_id: Optional[PyObjectId] = None
    position: str
    company_id: Optional[PyObjectId] = None
    assigned_students: List[PyObjectId] = []  # List of student IDs
    qualifications: List[str] = []
    areas_of_expertise: List[str] = []
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class EvaluationCriteria(BaseModelWithConfig):
    criterion: str
    score: float
    max_score: float
    weight: float

class Evaluation(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    application_id: PyObjectId
    supervisor_id: PyObjectId
    evaluation_type: str  # E.g., 'Midterm', 'Final'
    evaluation_date: datetime
    criteria: List[EvaluationCriteria]
    total_score: float
    max_total_score: float
    comments: Optional[str] = None
    strengths: List[str] = []
    areas_for_improvement: List[str] = []
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Notification(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    user_id: PyObjectId
    title: str
    description: str
    notification_type: str  # E.g., 'Application Status', 'Reminder'
    picture_url: Optional[HttpUrl] = None
    link: Optional[HttpUrl] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    read: bool = False
    read_at: Optional[datetime] = None

class VisitLocation(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    supervisor_id: PyObjectId
    student_id: PyObjectId
    internship_id: PyObjectId
    company_id: PyObjectId
    source_location: Address
    destination_location: Address
    visit_date: datetime
    status: str  # E.g., 'Completed', 'Pending'
    notes: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class AppCredentials(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    app_id: str
    app_key: str
    app_name: str
    description: str
    created_by: PyObjectId
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    last_used: Optional[datetime] = None
    is_active: bool = True

class DailyLog(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    student_id: PyObjectId
    internship_id: PyObjectId
    date: datetime
    activities: List[str]
    learning_outcomes: List[str]
    challenges: Optional[str] = None
    hours_worked: float
    status: str  # E.g., 'Submitted', 'Reviewed'
    supervisor_comments: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class WeeklyReport(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    student_id: PyObjectId
    internship_id: PyObjectId
    week_start_date: datetime
    week_end_date: datetime
    summary: str
    key_learnings: List[str]
    challenges: Optional[str] = None
    goals_for_next_week: List[str]
    status: str  # E.g., 'Submitted', 'Reviewed'
    supervisor_comments: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class FinalReport(BaseModelWithConfig):
    id: Annotated[PyObjectId, Field(default_factory=PyObjectId, alias="_id")]
    student_id: PyObjectId
    internship_id: PyObjectId
    submission_date: datetime
    report_url: HttpUrl
    executive_summary: str
    learnings: List[str]
    challenges: List[str]
    recommendations: List[str]
    status: str  # E.g., 'Submitted', 'Reviewed'
    supervisor_comments: Optional[str] = None
    grade: Optional[float] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class Token(BaseModelWithConfig):
    access_token: str
    token_type: str
    expires_at: datetime
base on the models.py and srs: fully rewrite the school-based supervisor services only, includes all functions and missing asctivities,for the current ones, keep it like that or modify it with teh new models:
#services.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta
from typing import Optional
from bson import ObjectId
from motor.motor_asyncio import AsyncIOMotorClient
from database.models import User, Student, Supervisor, Evaluation, Notification, VisitLocation, AppCredentials, Token
from database.config import MONGODB_URI, DATABASE_NAME, SECRET_KEY, ALGORITHM, ACCESS_TOKEN_EXPIRE_DAYS

# Create a MongoDB client
client = AsyncIOMotorClient(MONGODB_URI)
db = client[DATABASE_NAME]

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def verify_app_credentials(app_id: str, app_key: str) -> bool:
    app_cred = await db.app_credentials.find_one({"app_id": app_id, "app_key": app_key})
    if app_cred:
        await db.app_credentials.update_one(
            {"_id": app_cred["_id"]},
            {"$set": {"last_used": datetime.utcnow()}}
        )
        return True
    return False

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

async def get_user(email: str):
    user_dict = await db.users.find_one({"email": email})
    if user_dict:
        return User(**user_dict)

async def authenticate_user(email: str, password: str):
    user = await get_user(email)
    if not user or not verify_password(password, user.password):
        return False
    return user

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(days=ACCESS_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return Token(access_token=encoded_jwt, token_type="bearer", expires_at=expire)

async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    user = await get_user(email=email)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_supervisor(current_user: User = Depends(get_current_user)):
    if current_user.role != "supervisor-school":
        raise HTTPException(status_code=400, detail="User is not a supervisor")
    return current_user

async def get_supervisor_dashboard(supervisor_id: str):
    supervisor = await db.supervisors.find_one({"_id": ObjectId(supervisor_id)})
    if not supervisor:
        raise HTTPException(status_code=404, detail="Supervisor not found")

    total_students = len(supervisor["assigned_students"])
    completed_supervisions = await db.evaluations.count_documents({"supervisor_id": ObjectId(supervisor_id)})
    pending_supervisions = total_students - completed_supervisions

    students = await db.students.find({"_id": {"$in": supervisor["assigned_students"]}}).to_list(None)
    notifications = await db.notifications.find({"user_id": ObjectId(supervisor_id)}).to_list(None)

    return {
        "location": supervisor["department"],
        "total_students": total_students,
        "completed_supervisions": completed_supervisions,
        "pending_supervisions": pending_supervisions,
        "students": students,
        "notifications": notifications
    }

async def search_students(supervisor_id: str, query: str):
    supervisor = await db.supervisors.find_one({"_id": ObjectId(supervisor_id)})
    if not supervisor:
        raise HTTPException(status_code=404, detail="Supervisor not found")

    students = await db.students.find({
        "_id": {"$in": supervisor["assigned_students"]},
        "$or": [
            {"first_name": {"$regex": query, "$options": "i"}},
            {"last_name": {"$regex": query, "$options": "i"}},
            {"contact_info.phone": {"$regex": query, "$options": "i"}},
            {"academic_info.institution": {"$regex": query, "$options": "i"}}
        ]
    }).to_list(None)
    return students

async def get_student_list(supervisor_id: str, status: Optional[str] = None):
    supervisor = await db.supervisors.find_one({"_id": ObjectId(supervisor_id)})
    if not supervisor:
        raise HTTPException(status_code=404, detail="Supervisor not found")

    query = {"_id": {"$in": supervisor["assigned_students"]}}
    if status:
        query.update({"status": status})

    students = await db.students.find(query).to_list(None)
    return students

async def update_student_status(student_id: str, status: str):
    result = await db.students.update_one(
        {"_id": ObjectId(student_id)},
        {"$set": {"status": status}}
    )
    if result.modified_count == 0:
        raise HTTPException(status_code=404, detail="Student not found")
    return {"message": "Student status updated successfully"}

async def get_visit_locations(supervisor_id: str):
    visit_locations = await db.visit_locations.find({"supervisor_id": ObjectId(supervisor_id)}).to_list(None)
    return visit_locations

async def create_visit_location(supervisor_id: str, visit_location: VisitLocation):
    visit_location_dict = visit_location.dict()
    visit_location_dict["supervisor_id"] = ObjectId(supervisor_id)
    result = await db.visit_locations.insert_one(visit_location_dict)
    return str(result.inserted_id)

async def update_visit_location(visit_location_id: str, visit_location: VisitLocation):
    result = await db.visit_locations.update_one(
        {"_id": ObjectId(visit_location_id)},
        {"$set": visit_location.dict(exclude={"id"})}
    )
    if result.modified_count == 0:
        raise HTTPException(status_code=404, detail="Visit location not found")
    return True

async def delete_visit_location(visit_location_id: str):
    result = await db.visit_locations.delete_one({"_id": ObjectId(visit_location_id)})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Visit location not found")
    return True

async def get_supervisor_profile(supervisor_id: str):
    supervisor = await db.supervisors.find_one({"_id": ObjectId(supervisor_id)})
    if not supervisor:
        raise HTTPException(status_code=404, detail="Supervisor not found")
    user = await db.users.find_one({"_id": supervisor["user_id"]})
    return {**supervisor, **user}

async def update_supervisor_profile(supervisor_id: str, profile_data: dict):
    result = await db.supervisors.update_one(
        {"_id": ObjectId(supervisor_id)},
        {"$set": profile_data}
    )
    if result.modified_count == 0:
        raise HTTPException(status_code=404, detail="Supervisor not found")
    return True

async def delete_supervisor(supervisor_id: str):
    supervisor = await db.supervisors.find_one({"_id": ObjectId(supervisor_id)})
    if not supervisor:
        raise HTTPException(status_code=404, detail="Supervisor not found")

    result = await db.supervisors.delete_one({"_id": ObjectId(supervisor_id)})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Supervisor not found")

    await db.users.delete_one({"_id": supervisor["user_id"]})
    return True

async def logout(token: str):
    await db.token_blacklist.insert_one({"token": token, "invalidated_at": datetime.utcnow()})
    return True

async def is_token_blacklisted(token: str):
    blacklisted_token = await db.token_blacklist.find_one({"token": token})
    return blacklisted_token is not None
 Supervision Management
**Description:** Manages the assignment and activities of school-based and company-based supervisors.

**Functional Requirements:**
- The system assigns school-based supervisors to students based on department and geographic location.
- School-based supervisors can view assigned students' locations and use GPS for navigation.
- School-based supervisors can view students' daily logs and activities.
- School-based supervisors can mark logbooks, endorse them, and provide comments.
- School-based supervisors can grade students' performance using a standardized form.
- The system balances supervisor workload based on student distribution and location.
- Supervisors can generate and submit evaluation reports.
DialyLogs are and weekly Logs and monthlyLogs, is the LogBook of students, of which is can be viewed and graded by supervisors, the Final Reporst is the report that student must submit after intenship and can be viewed only by the Department and ILO
update the full code... base on the requirements